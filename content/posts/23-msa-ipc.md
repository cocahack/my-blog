---
title: MSA의 IPC
date: "2021-12-04T09:38:05Z"
template: "post"
draft: false
slug: "23"
category: "MSA"
tags:
  - "MSA"
  - "Book - 마이크로서비스 패턴"
description: ""
---

## IPC

### Interaction에 따른 분류

- 1:1, 1:N
  - 1:1: 각 클라이언트의 요청은 정확히 한 서비스가 처리한다.
  - 1:N: 각 클라이언트의 요청을 여러 서비스가 협동하여 처리한다.
- 동기/비동기
  - 동기: 클라이언트는 서비스가 제시간에 응답할 것이라 기대하고 대기 도중 블로킹될 수 있다.
  - 비동기: 클라이언트는 블로킹되지 않으며, 응답은 나중에 전달된다.

#### 위 분류에 따른 interaction 방법

- 1:1
  - 동기
    - 요청/응답
  - 비동기
    - 비동기 요청/응답
    - 단방향 알림
- 1:N
  - 비동기
    - 발행/구독
    - 발행/비동기 응답

### REST

리소스를 HTTP 동사를 사용해 URL로 참조되는 리소스를 가공한다. 

#### REST 성숙도 

- 레벨 0: 리소스 구분없이 RPC 형태로 설계된 HTTP API
- 레벨 1: 리소스 개념을 지원한다. 클라이언트는 수행할 액션과 매개변수가 지정된 POST 요청을 한다. 
- 레벨 2: HTTP 동사를 이용해 액션을 수행하고, 요청 쿼리 매개변수 및 body, 필요 시 매개변수를 지정한다.
- 레벨 3: HATEOAS 원칙으로 설계한다. GET 요청으로 반환된 리소스에 그 리소스에 대한 액션도 함께 보낸다.

#### REST API 단점

- 요청 한 번으로 많은 리소스를 가져오기 어렵다. 연관된 객체를 가져오려면 순수 REST API에서는 최소 두 번의 요청이 있어야 한다. 이런 문제 때문에 GraphQL 같은 기술이 나오게 되었다.
- 작업을 HTTP 동사에 매핑하기 어렵다. 여러 대안이 있지만 REST 하지 않기 때문에 gRPC 등 대체 기술을 사용하기도 한다.
- 요청/응답 스타일의 통신만 지원

### gRPC

Protocol buffer 기반의 IDL 로 API를 정의하며, Protocol buffer 컴파일러로 클라이언트 쪽 스텁과 서버 스켈레톤 코드를 생성할 수 있다.

#### 장단점

- 장점
  - REST로 표현하기 힘들었던 작업을 표현할 수 있다.
  - 바이너리 메시지 기반이므로 큰 메시지를 교환할 때 HTTP보다 유리하다.
  - 양방향 스트리밍을 지원하여 RPI, 메시징 방식 모두 가능하다.
  - 다양한 언어를 지원한다.
- 단점
  - 클라이언트가 해야할 일이 REST/JSON 기반 API보다 더 많다.
  - HTTP/2 에서만 동작하므로, 호환성 문제가 발생할 수 있다.


## 서비스 부분 실패를 대처하는 방법

MSA에서 특정 서비스가 요청을 주지 않으면 그 서비스와 동기 통신하는 다른 서비스에 영향을 준다. 응답이 제 때 오지 않기 때문에 쓰레드와 같은 주요 자원이 고갈되면서 응답을 주지 못하게 되고, 이런 현상이 다른 서비스에 모두 전파되는 것이다.

이를 막기 위헤 두 가지를 고려해야 한다. 

- 응답하지 않는 서비스를 처리하기 위해 견고한 RPI 프록시를 설계
  - 네트워크 타임아웃: 무한히 블록되지 않도록 항상 타임아웃을 건다.
  - 미처리 요청(outstanding request) 개수 제한: 클라이언트가 특정 서비스에 요청할 수 있는 미처리 요청의 최대 개수를 설정한다. 이 개수를 넘어가면 그 이후의 요청은 즉시 실패 처리한다.
  - Circuit breaker 패턴: 성공/실패 요청 개수를 지켜보다가 에러 비율이 임계치를 초과하면 그 이후 시도를 바로 실패 처리한다. 
  > Netfilx 블로그 참고 [링크](https://netflixtechblog.com/fault-tolerance-in-a-high-volume-distributed-system-91ab4faae74a)
- 서비스가 실패하면 어떻게 조치할지 결정
  - 클라이언트에 에러 반환
  - 미리 정해진 기본 값 또는 캐시된 응답 등 fallback value를 반환

## 곳곳에 흩어진 서비스를 식별하는 방법

연관된 다른 서비스를 호출하기 위해서는 네트워크 상에서 통용되는 식별자를 알아야 한다. 클라우드 기반 환경에서 이러한 식별자는 
언제 어떻게 바뀔지 알 수 없다. 때문에 서비스 위치를 알려줄 수 있는 **서비스 디스커버리** 메커니즘이 반드시 필요하다.

### 서비스 레지스트리

서비스 인스턴스의 네트워크 위치를 DB화 한 서비스 레지스트리가 있다. 서비스 인스턴스가 시작, 종료 할 때마다 서비스 레지스트리가 업데이트된다. 

#### 레지스트리 등록 방식

등록 방식에는 자가 등록 방식과 서드 파티 등록 방식이 있다.

##### Self registration

자가 등록 방식은 서비스가 직접 서비스 레지스트리에 자신의 네트워크 정보를 등록한다. 서비스는 레지스트리가 서비스가 정상 상태임을 알 수 있게 반드시 주기적으로 자신의 상태를 갱신해줘야 한다. 서비스를 정지할 때, 서비스 인스턴스는 서비스 레지스트리에 자신의 등록 정보를 지운다.
마이크로서비스 섀시 프레임워크로 처리할 수 있다.

##### 3-party Registration

서드 파티 등록 방식은 서드 파티 레지스트라가 서비스 인스턴스의 등록 책임을 맡는다. 도커나 쿠버네티스 등 플랫폼에서 이러한 메커니즘을 탑재하고 있다.

### 서비스 디스커버리

디스커버리 방식도 Client-side discovery와 Server-side discovery 로 나뉜다. 전자는 서비스의 클라이언트가 서비스 레지스트리에 있는 서비스 인스턴스 목록을 조회하고 직접 부하 분산 알고리즘을 이용하여 인스턴스를 선택한다. 후자는 서비스 클라이언트가 DNS를 사용하여 요청하며, 이 요청은 서비스 디스커버리를 담당하는 라우터에게 전달된다. 라우터는 Client-side discovery 방식과 유사하게 동작한다.

#### 어떤 서비스 디스커버리 패턴을 사용할 것인가?

Client-side discovery는 프레임워크의 기능으로 구현할 수 있다. 때문에 인프라에 상관없이 적용할 수 있다. 반면 Server-side discovery는 사용하고 있는 플랫폼에 종속된다. Client-side discovery는 인프라에 종속되지는 않지만, 프레임워크와 프로그래밍 언어에 종속된다. 

정답은 없다고 생각한다. 이러한 특성을 보고 상황에 맞는 방식을 적절히 채택하면 될 것 같다.

## 비동기 메시징 패턴

메시징 패턴은 클라이언트가 비동기 메시징을 통해 서비스를 호출하는 패턴이다.

### Basis

- 메시지: 헤더와 본문으로 구성된다. 메시지 종류에는 document, command, event 등이 있다.
  - Document: 데이터만 포함된 제네릭한 메시지이다. 어떻게 해석할지는 수신자가 결정해야 한다.
  - Command: RPC 요청과 동등하다. 호출할 작업과 작업에 필요한 argument를 포함한다.
  - event: 송신자에게 어떤 사건이 발생했음을 알리는 메시지이다. 대부분 도메인 객체의 상태 변화를 나타낼 때 쓴다.
- 메시지 채널: 메시지는 채널을 통해 교환된다. 
  - Point-to-Point 채널: 채널을 읽는 컨슈머 중 딱 하나만 지정하여 메시지를 전달한다.
  - Publish-Subscribe 채널: 같은 채널을 바라보는 모든 컨슈머에 메시지를 전달한다.

#### 메시징 상호 작용 스타일
  - 요청/응답, 비동기 요청/응답: 클라이언트가 요청을 보내면 서비스는 응답을 반환하는 전형적인 방식. 메시징은 원래 비동기로 동작하나, 
  응답을 수신할 때까지 블로킹하는 것도 가능하다. 요청과 응답이 짝이 맞아야 하므로, 고유 ID를 사용하여 이를 해결한다.
  - 단방향 알림: 서비스가 소유한 Point-to-Point 채널로 클라이언트가 메시지를 보내면, 서비스가 이 채널을 구독해서 메시지를 처리한다. 단방향이므로 응답을 보내지 않는다.
  - 발행/구독: 클라이언트는 여러 컨슈머가 읽는 pub/sub 채널에 메시지를 발행하고, 서비스는 도메인 객체의 변경 사실을 알리는 도메인 이벤트를 발행한다. 
  - 발행/비동기 응답: 발행/구독, 요청/응답 스타일을 조합한 방식. 클라이언트는 응답 채널 헤더가 명시된 메시지를 pub/sub 채널에 발행하고, 컨슈머는 Correlation ID가 포함된 응답 메시지를 지정된 응답 채널에 쓴다. 클라이언트는 Correlation ID로 응답을 취합하여 응답 메시지와 요청을 맞춰본다.

#### 메시지 브로커

메시지 브로커는 서비스가 서로 통신할 수 있게 해주는 인프라 서비스이다.

##### 브로커리스 메시징

이 아키텍처에서 서비스는 메시지를 직접 교환한다. 대표적인 솔루션에는 ZeroMQ가 있다. 

- 장점
  - 직접 메시지가 전달되므로 브로커를 사용하는 방식보다 네트워크를 덜 탄다.
  - 메시지 브로커를 쓰면서 발생하는 SPoF 또는 병목점 이슈를 제거할 수 있다.
  - 메시지 브로커를 쓰지 않으므로 운영 복잡도가 낮다.
- 단점
  - 서비스가 서로 위치를 알아야 하므로 서비스 디스커버리 메커니즘을 반드시 써야 한다.
  - 메시지 교환 시 송/수신자가 모두 실행 중이어야 하므로 가용성이 떨어진다.
  - 전달 보장같은 메커니즘을 구현하기 어렵다.

##### 브로커 기반 메시징

서비스 사이에 메시지 브로커가 있어서 이 브로커가 메시지를 주고 받을 수 있게 해준다. 

널리 알려진 메시지 브로커 솔루션은 ActiveMQ, RabbitMQ, Kafka 등이 있다. 그 외 AWS kinesis, SQS 등 클라우드 벤더가 제공하는 메시지 서비스도 있다. 

이렇게 여러 솔루션이 있는데, 솔루션의 특성과 애플리케이션의 워크로드가 필요로 하는 기능을 잘 비교하여 적절한 것을 선택해야 한다.
예를 들어, 지연 시간이 매우 짧은 브로커는 메시지 순서가 유지되지 않거나 메시지 전달을 반드시 보장하지 않는다거나, 메시지를 메모리에만 저장하여 재시작 시 복구가 안된다거나 하는 등의 문제가 있을 수 있다.

###### 장단점

- 장점
  - 느슨한 결합: 메시지 브로커에 보내기만 하면 되기 때문에, 서비스 인스턴스를 알 필요가 없다. 따라서 서비스 디스커버리 메커니즘도 필요 없다.
  - 메시지 버퍼링: HTTP 같은 동기 요청/응답 프로토콜에서는 클라이언트/서비스 모두 가용한 상태여아 하지만, 브로커 기반 메시징에서는 서비스가 죽은 상태에서도 계속 큐에 쌓이기만 한다.
  - 유연한 통신: 모든 상호 작용 방식을 지원한다. (동기/비동기, 일대일/일대다)
- 단점
  - 성능 병목점, SPoF이 될 수 있다.
  - 운영 복잡도가 올라간다.

### 메시징을 사용하면서 발생하는 문제들

#### 수신자 경합과 메시지 순서 유지

메시지 수신자를 스케일 아웃하면 여러 메시지를 동시에 처리할 수 있다. 그러나 메시지를 정확히 한 번만 순서대로 처리해야만 한다. 
어떤 이벤트 메시지들을 한 번에 보낸다고 할 때, 차례대로 보내더라도 네트워크나 GC 등으로 인한 지연으로 메시지 처리 순서가 어긋날 수 있다. 이렇게 되면 시스템이 오동작하게 되는 것이다.

카프카, AWS 키네시스 등 솔루션들은 샤딩된 채널을 이용하여 문제를 해결한다. 일련의 이벤트가 내부적으로는 하나의 수신자에서만 처리되기 때문에 메시지 처리 순서가 보장되는 것이다.

#### 중복 메시지 처리

메시지 브로커가 반드시 한 번만 메시지를 전달하게 보장해야 한다면 그만한 대가를 치러야하기 때문에 대부분의 브로커들은 보통 적어도 한 번 이상 메시지를 전달한다. 때문에 메시지를 여러 번 전달할 가능성이 있는 것이다. 

이런 중복 메시지를 처리하는 방법은 두 가지가 있다.

- 멱등성을 보장하는 메시지 핸들러: 몇 번을 실행해도 항상 같은 결과를 만들어내면 된다. 그러나 이런 상황은 흔치 않다.
- 메시지 추적과 중복 메시지 제거: 컨슈머가 메시지 ID를 이용해 메시지 처리 여부를 추적하는 방법을 쓸 수 있다. 가장 간단한 방법은 DB 테이블에 ID를 저장하는 것이다.

#### 트랜잭셔널 메시지

서비스는 보통 DB를 업데이트하는 트랜잭션의 일부로 메시지를 발행한다. 트랜잭션과 메시지 전송을 묶지 않으면 DB 업데이트는 됐으나 메세지를 전송하지 않는 상황이 발생할 수도 있다.

이를 해결하기 위해 DB 테이블을 메시지 큐로 활용하는 방법이 있다.

비즈니스 객체에 CUD 하는 DB 트랜잭션에 메시지 큐 대용으로 사용할 테이블에 메시지를 삽입하는 방법이다. 트랜잭션 내에서 실행되므로 원자성이 보장된다. 

이렇게 저장된 메시지는 메시지 릴레이가 읽어 대신 메시지 브로커에 전달해준다.

여기서 메시지 릴레이를 구현하는 패턴이 또 두 가지가 있다.

하나는 폴링 발행기 패턴으로 테이블에 레코드가 추가되는지 주기적으로 확인하고, 레코드를 발견하면 메시지를 발행하고 레코드를 제거한다.

다른 하나는 트랜잭션 로그 테일링 패턴이다. DB 트랜잭션 로그를 읽어 변경분을 하나씩 메시지 브로커에 발행하는 방식이다.

