---
title: 1회차 학습 내용 정리
date: "2021-08-05T22:27:31Z"
template: "post"
draft: true
slug: "6"
category: "Record"
tags:
  - "Record"
description: "1회차 수업 및 숙제를 정리"
---

> "자바의 신" Vol. 1 1장 ~ 7장 범위

## 클래스

클래스는 자바에서 가장 작은 단위(Primitive Type은 논외)이다. 

클래스는 분류에 대한 개념이라고 할 수 있다. 그 개념을 속성과 행동으로 나타낸 것이 바로 프로그래밍에서의 클래스이다.

## 타입 

자바에는 Primitive Type과 Reference Type이 있다.

### Primitive Type

byte, char, short, int, long, float, double, boolean 등이 이에 속한다. 

#### 특징

- Primitive Type 의 변수는 값을 가진다는 특징이 있다.
- `==` 연산자를 사용해 같은 타입의 두 변수를 비교할 수 있다. 
- 변수를 초기화하면 스택에 할당된다.

### Reference Type

Primitive Type이 아닌 모든 타입은 Reference Type 이다. 때문에 배열도 Reference Type이다.

#### 특징

- 객체를 생성하면 힙 영역에 할당된다.
- 변수는 객체의 위치를 가리키는 주소 값을 가지고 있다. 이를 참조라고 부른다.

##### 비교

`==` 연산자를 사용하면 두 Reference Type 변수의 주소 값을 비교한다. 

`equals()` 를 사용하는 방법도 있다. `equals()` 의 기본 구현은 `==` 연산자를 사용한 것이지만, 
재정의하면 구현 방법에 따라 객체가 가진 필드로 비교하는 것이 가능하다.

`equals()` 메소드를 재정의했다면 반드시 `hashCode()` 도 재정의해야 한다. 
`hashCode()` 는 `equals()` 의 결과가 `true` 가 되는 두 객체가 있다면, 
두 객체에 각각 `hashCode()` 메소드를 사용했을 때 나오는 값이 반드시 같아야 한다는 자바 명세가 있기 때문이다.  
만약 이를 어긴다면 `hashCode()` 를 사용하는 다른 기능(예를 들면, `HashMap`)이 오작동하는 문제가 있다.

## Garbage Collection

더 이상 참조되지 않은 객체를 힙에서 제거하는 것. 

### mark-and-sweep

더 이상 참조되지 않는 객체를 판별하고 제거하는 알고리즘. 

두 개의 절차로 나눌 수 있다.

1. mark: 참조되고 있는 객체를 마킹하는 단계. GC root부터 시작해서 참조를 따라가 마킹한다. 가장 쉬운 구현 방법으로는 DFS 가 있다.
    - GC root 가 될 수 있는 것은 다음과 같다.
        - 지역 변수
        - 메인 쓰레드
        - 메인 클래스의 static 변수
        - etc.
2. sweep: 단어 그대로 참조되고 있지 않은 객체를 *쓸어버린다*. 힙에서 이런 객체들을 할당 해제하고 나면, 다음 GC를 위해 남아 있는 객체의 마킹을 초기화한다.

## 저장 장치 

메모리와 디스크의 차이는 무엇인가? 휘발성과 속도다.
매모리는 저장된 데이터를 영구적으로 저장하지 못하지만, 디스크는 그렇지 않다. 대신 메모리는 액세스 속도가 디스크에 비해 월등히 빠르다.

또, CPU와 메모리 사이의 속도 차를 완화하기 위해 캐시를 사용한다. 캐시에 비하면 메모리의 속도는 현저하게 느리다. 
그러나 비용적인 측면과 효율성 때문에 캐시의 크기는 메모리에 비하면 매우 작다.

### In Practical..

- Q1: 요구되는 Write IOPS 가 Disk 의 IOPS 를 넘어가는 경우는 어떻게 해야 하는가? 
    - 이런 상황은 언제 발생할 수 있는가? : 회원 가입, 주문, 메시지 입력 등등 수많은 상황이 있을 수 있다.
    - 속도의 불일치를 완화해줄 무언가가 필요하다. 인메모리 DB 를 사용해 캐싱할 수 있을 것아다.
- Q2: 단일 처리보다 bulk 처리가 더 빠른 경우가 있다. 언제인가? 그리고 그 이유는 무엇인가?
    - 네트워크 통신과 같은 작업에서는 연결 수립 과정이 필요하며 이것 또한 비용이 된다.  
      이런 비용을 아끼기 위해서라도 최대한 한 번에 보내는 것이 좋다.
